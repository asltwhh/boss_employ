{"ast":null,"code":"import _extends from 'babel-runtime/helpers/extends';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\n/* tslint:disable:no-console */\n\nimport React, { Component } from 'react';\nimport { calcRotation, getEventName, now, calcMutliFingerStatus, calcMoveStatus, shouldTriggerSwipe, shouldTriggerDirection, getMovingDirection, getDirectionEventName } from './util';\nimport { PRESS, DIRECTION_ALL, DIRECTION_VERTICAL, DIRECTION_HORIZONTAL } from './config';\n;\n;\nvar directionMap = {\n  all: DIRECTION_ALL,\n  vertical: DIRECTION_VERTICAL,\n  horizontal: DIRECTION_HORIZONTAL\n};\n\nvar Gesture = function (_Component) {\n  _inherits(Gesture, _Component);\n\n  function Gesture(props) {\n    _classCallCheck(this, Gesture);\n\n    var _this = _possibleConstructorReturn(this, (Gesture.__proto__ || Object.getPrototypeOf(Gesture)).call(this, props));\n\n    _this.state = {};\n\n    _this.triggerEvent = function (name) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var cb = _this.props[name];\n\n      if (typeof cb === 'function') {\n        // always give user gesture object as first params first\n        cb.apply(undefined, [_this.getGestureState()].concat(args));\n      }\n    };\n\n    _this.triggerCombineEvent = function (mainEventName, eventStatus) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      _this.triggerEvent.apply(_this, [mainEventName].concat(args));\n\n      _this.triggerSubEvent.apply(_this, [mainEventName, eventStatus].concat(args));\n    };\n\n    _this.triggerSubEvent = function (mainEventName, eventStatus) {\n      for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        args[_key3 - 2] = arguments[_key3];\n      }\n\n      if (eventStatus) {\n        var subEventName = getEventName(mainEventName, eventStatus);\n\n        _this.triggerEvent.apply(_this, [subEventName].concat(args));\n      }\n    };\n\n    _this.triggerPinchEvent = function (mainEventName, eventStatus) {\n      for (var _len4 = arguments.length, args = Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n        args[_key4 - 2] = arguments[_key4];\n      }\n\n      var scale = _this.gesture.scale;\n\n      if (eventStatus === 'move' && typeof scale === 'number') {\n        if (scale > 1) {\n          _this.triggerEvent('onPinchOut');\n        }\n\n        if (scale < 1) {\n          _this.triggerEvent('onPinchIn');\n        }\n      }\n\n      _this.triggerCombineEvent.apply(_this, [mainEventName, eventStatus].concat(args));\n    };\n\n    _this.initPressTimer = function () {\n      _this.cleanPressTimer();\n\n      _this.pressTimer = setTimeout(function () {\n        _this.setGestureState({\n          press: true\n        });\n\n        _this.triggerEvent('onPress');\n      }, PRESS.time);\n    };\n\n    _this.cleanPressTimer = function () {\n      /* tslint:disable:no-unused-expression */\n      _this.pressTimer && clearTimeout(_this.pressTimer);\n    };\n\n    _this.setGestureState = function (params) {\n      if (!_this.gesture) {\n        _this.gesture = {};\n      } // cache the previous touches\n\n\n      if (_this.gesture.touches) {\n        _this.gesture.preTouches = _this.gesture.touches;\n      }\n\n      _this.gesture = _extends({}, _this.gesture, params);\n    };\n\n    _this.getGestureState = function () {\n      if (!_this.gesture) {\n        return _this.gesture;\n      } else {\n        // shallow copy\n        return _extends({}, _this.gesture);\n      }\n    };\n\n    _this.cleanGestureState = function () {\n      delete _this.gesture;\n    };\n\n    _this.getTouches = function (e) {\n      return Array.prototype.slice.call(e.touches).map(function (item) {\n        return {\n          x: item.screenX,\n          y: item.screenY\n        };\n      });\n    };\n\n    _this.triggerUserCb = function (status, e) {\n      var cbName = getEventName('onTouch', status);\n\n      if (cbName in _this.props) {\n        _this.props[cbName](e);\n      }\n    };\n\n    _this._handleTouchStart = function (e) {\n      _this.triggerUserCb('start', e);\n\n      _this.event = e;\n\n      if (e.touches.length > 1) {\n        e.preventDefault();\n      }\n\n      _this.initGestureStatus(e);\n\n      _this.initPressTimer();\n\n      _this.checkIfMultiTouchStart();\n    };\n\n    _this.initGestureStatus = function (e) {\n      _this.cleanGestureState(); // store the gesture start state\n\n\n      var startTouches = _this.getTouches(e);\n\n      var startTime = now();\n      var startMutliFingerStatus = calcMutliFingerStatus(startTouches);\n\n      _this.setGestureState({\n        startTime: startTime,\n        startTouches: startTouches,\n        startMutliFingerStatus: startMutliFingerStatus,\n\n        /* copy for next time touch move cala convenient*/\n        time: startTime,\n        touches: startTouches,\n        mutliFingerStatus: startMutliFingerStatus,\n        srcEvent: _this.event\n      });\n    };\n\n    _this.checkIfMultiTouchStart = function () {\n      var _this$props = _this.props,\n          enablePinch = _this$props.enablePinch,\n          enableRotate = _this$props.enableRotate;\n      var touches = _this.gesture.touches;\n\n      if (touches.length > 1 && (enablePinch || enableRotate)) {\n        if (enablePinch) {\n          var startMutliFingerStatus = calcMutliFingerStatus(touches);\n\n          _this.setGestureState({\n            startMutliFingerStatus: startMutliFingerStatus,\n\n            /* init pinch status */\n            pinch: true,\n            scale: 1\n          });\n\n          _this.triggerCombineEvent('onPinch', 'start');\n        }\n\n        if (enableRotate) {\n          _this.setGestureState({\n            /* init rotate status */\n            rotate: true,\n            rotation: 0\n          });\n\n          _this.triggerCombineEvent('onRotate', 'start');\n        }\n      }\n    };\n\n    _this._handleTouchMove = function (e) {\n      _this.triggerUserCb('move', e);\n\n      _this.event = e;\n\n      if (!_this.gesture) {\n        // sometimes weird happen: touchstart -> touchmove..touchmove.. --> touchend --> touchmove --> touchend\n        // so we need to skip the unnormal event cycle after touchend\n        return;\n      } // not a long press\n\n\n      _this.cleanPressTimer();\n\n      _this.updateGestureStatus(e);\n\n      _this.checkIfSingleTouchMove();\n\n      _this.checkIfMultiTouchMove();\n    };\n\n    _this.checkIfMultiTouchMove = function () {\n      var _this$gesture = _this.gesture,\n          pinch = _this$gesture.pinch,\n          rotate = _this$gesture.rotate,\n          touches = _this$gesture.touches,\n          startMutliFingerStatus = _this$gesture.startMutliFingerStatus,\n          mutliFingerStatus = _this$gesture.mutliFingerStatus;\n\n      if (!pinch && !rotate) {\n        return;\n      }\n\n      if (touches.length < 2) {\n        _this.setGestureState({\n          pinch: false,\n          rotate: false\n        }); // Todo: 2 finger -> 1 finger, wait to test this situation\n\n\n        pinch && _this.triggerCombineEvent('onPinch', 'cancel');\n        rotate && _this.triggerCombineEvent('onRotate', 'cancel');\n        return;\n      }\n\n      if (pinch) {\n        var scale = mutliFingerStatus.z / startMutliFingerStatus.z;\n\n        _this.setGestureState({\n          scale: scale\n        });\n\n        _this.triggerPinchEvent('onPinch', 'move');\n      }\n\n      if (rotate) {\n        var rotation = calcRotation(startMutliFingerStatus, mutliFingerStatus);\n\n        _this.setGestureState({\n          rotation: rotation\n        });\n\n        _this.triggerCombineEvent('onRotate', 'move');\n      }\n    };\n\n    _this.allowGesture = function () {\n      return shouldTriggerDirection(_this.gesture.direction, _this.directionSetting);\n    };\n\n    _this.checkIfSingleTouchMove = function () {\n      var _this$gesture2 = _this.gesture,\n          pan = _this$gesture2.pan,\n          touches = _this$gesture2.touches,\n          moveStatus = _this$gesture2.moveStatus,\n          preTouches = _this$gesture2.preTouches,\n          _this$gesture2$availa = _this$gesture2.availablePan,\n          availablePan = _this$gesture2$availa === undefined ? true : _this$gesture2$availa;\n\n      if (touches.length > 1) {\n        _this.setGestureState({\n          pan: false\n        }); // Todo: 1 finger -> 2 finger, wait to test this situation\n\n\n        pan && _this.triggerCombineEvent('onPan', 'cancel');\n        return;\n      } // add avilablePan condition to fix the case in scrolling, which will cause unavailable pan move.\n\n\n      if (moveStatus && availablePan) {\n        var direction = getMovingDirection(preTouches[0], touches[0]);\n\n        _this.setGestureState({\n          direction: direction\n        });\n\n        var eventName = getDirectionEventName(direction);\n\n        if (!_this.allowGesture()) {\n          // if the first move is unavailable, then judge all of remaining touch movings are also invalid.\n          if (!pan) {\n            _this.setGestureState({\n              availablePan: false\n            });\n          }\n\n          return;\n        }\n\n        if (!pan) {\n          _this.triggerCombineEvent('onPan', 'start');\n\n          _this.setGestureState({\n            pan: true,\n            availablePan: true\n          });\n        } else {\n          _this.triggerCombineEvent('onPan', eventName);\n\n          _this.triggerSubEvent('onPan', 'move');\n        }\n      }\n    };\n\n    _this.checkIfMultiTouchEnd = function (status) {\n      var _this$gesture3 = _this.gesture,\n          pinch = _this$gesture3.pinch,\n          rotate = _this$gesture3.rotate;\n\n      if (pinch) {\n        _this.triggerCombineEvent('onPinch', status);\n      }\n\n      if (rotate) {\n        _this.triggerCombineEvent('onRotate', status);\n      }\n    };\n\n    _this.updateGestureStatus = function (e) {\n      var time = now();\n\n      _this.setGestureState({\n        time: time\n      });\n\n      if (!e.touches || !e.touches.length) {\n        return;\n      }\n\n      var _this$gesture4 = _this.gesture,\n          startTime = _this$gesture4.startTime,\n          startTouches = _this$gesture4.startTouches,\n          pinch = _this$gesture4.pinch,\n          rotate = _this$gesture4.rotate;\n\n      var touches = _this.getTouches(e);\n\n      var moveStatus = calcMoveStatus(startTouches, touches, time - startTime);\n      var mutliFingerStatus = void 0;\n\n      if (pinch || rotate) {\n        mutliFingerStatus = calcMutliFingerStatus(touches);\n      }\n\n      _this.setGestureState({\n        /* update status snapshot */\n        touches: touches,\n        mutliFingerStatus: mutliFingerStatus,\n\n        /* update duration status */\n        moveStatus: moveStatus\n      });\n    };\n\n    _this._handleTouchEnd = function (e) {\n      _this.triggerUserCb('end', e);\n\n      _this.event = e;\n\n      if (!_this.gesture) {\n        return;\n      }\n\n      _this.cleanPressTimer();\n\n      _this.updateGestureStatus(e);\n\n      _this.doSingleTouchEnd('end');\n\n      _this.checkIfMultiTouchEnd('end');\n    };\n\n    _this._handleTouchCancel = function (e) {\n      _this.triggerUserCb('cancel', e);\n\n      _this.event = e; // Todo: wait to test cancel case\n\n      if (!_this.gesture) {\n        return;\n      }\n\n      _this.cleanPressTimer();\n\n      _this.updateGestureStatus(e);\n\n      _this.doSingleTouchEnd('cancel');\n\n      _this.checkIfMultiTouchEnd('cancel');\n    };\n\n    _this.triggerAllowEvent = function (type, status) {\n      if (_this.allowGesture()) {\n        _this.triggerCombineEvent(type, status);\n      } else {\n        _this.triggerSubEvent(type, status);\n      }\n    };\n\n    _this.doSingleTouchEnd = function (status) {\n      var _this$gesture5 = _this.gesture,\n          moveStatus = _this$gesture5.moveStatus,\n          pinch = _this$gesture5.pinch,\n          rotate = _this$gesture5.rotate,\n          press = _this$gesture5.press,\n          pan = _this$gesture5.pan,\n          direction = _this$gesture5.direction;\n\n      if (pinch || rotate) {\n        return;\n      }\n\n      if (moveStatus) {\n        var z = moveStatus.z,\n            velocity = moveStatus.velocity;\n        var swipe = shouldTriggerSwipe(z, velocity);\n\n        _this.setGestureState({\n          swipe: swipe\n        });\n\n        if (pan) {\n          // pan need end, it's a process\n          // sometimes, start with pan left, but end with pan right....\n          _this.triggerAllowEvent('onPan', status);\n        }\n\n        if (swipe) {\n          var directionEvName = getDirectionEventName(direction); // swipe just need a direction, it's a endpoint\n\n          _this.triggerAllowEvent('onSwipe', directionEvName);\n\n          return;\n        }\n      }\n\n      if (press) {\n        _this.triggerEvent('onPressUp');\n\n        return;\n      }\n\n      _this.triggerEvent('onTap');\n    };\n\n    _this.getTouchAction = function () {\n      var _this$props2 = _this.props,\n          enablePinch = _this$props2.enablePinch,\n          enableRotate = _this$props2.enableRotate;\n      var directionSetting = _this.directionSetting;\n\n      if (enablePinch || enableRotate || directionSetting === DIRECTION_ALL) {\n        return 'pan-x pan-y';\n      }\n\n      if (directionSetting === DIRECTION_VERTICAL) {\n        return 'pan-x';\n      }\n\n      if (directionSetting === DIRECTION_HORIZONTAL) {\n        return 'pan-y';\n      }\n\n      return 'auto';\n    };\n\n    _this.directionSetting = directionMap[props.direction];\n    return _this;\n  }\n\n  _createClass(Gesture, [{\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      this.cleanPressTimer();\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var children = this.props.children;\n      var child = React.Children.only(children);\n      var touchAction = this.getTouchAction();\n      var events = {\n        onTouchStart: this._handleTouchStart,\n        onTouchMove: this._handleTouchMove,\n        onTouchCancel: this._handleTouchCancel,\n        onTouchEnd: this._handleTouchEnd\n      };\n      return React.cloneElement(child, _extends({}, events, {\n        style: _extends({\n          touchAction: touchAction\n        }, child.props.style || {})\n      }));\n    }\n  }]);\n\n  return Gesture;\n}(Component);\n\nexport default Gesture;\nGesture.defaultProps = {\n  enableRotate: false,\n  enablePinch: false,\n  direction: 'all'\n};","map":{"version":3,"sources":["E:/workspaces/github/Boss_React/gzhipin-client1.0/node_modules/rc-gesture/es/index.js"],"names":["_extends","_classCallCheck","_createClass","_possibleConstructorReturn","_inherits","React","Component","calcRotation","getEventName","now","calcMutliFingerStatus","calcMoveStatus","shouldTriggerSwipe","shouldTriggerDirection","getMovingDirection","getDirectionEventName","PRESS","DIRECTION_ALL","DIRECTION_VERTICAL","DIRECTION_HORIZONTAL","directionMap","all","vertical","horizontal","Gesture","_Component","props","_this","__proto__","Object","getPrototypeOf","call","state","triggerEvent","name","_len","arguments","length","args","Array","_key","cb","apply","undefined","getGestureState","concat","triggerCombineEvent","mainEventName","eventStatus","_len2","_key2","triggerSubEvent","_len3","_key3","subEventName","triggerPinchEvent","_len4","_key4","scale","gesture","initPressTimer","cleanPressTimer","pressTimer","setTimeout","setGestureState","press","time","clearTimeout","params","touches","preTouches","cleanGestureState","getTouches","e","prototype","slice","map","item","x","screenX","y","screenY","triggerUserCb","status","cbName","_handleTouchStart","event","preventDefault","initGestureStatus","checkIfMultiTouchStart","startTouches","startTime","startMutliFingerStatus","mutliFingerStatus","srcEvent","_this$props","enablePinch","enableRotate","pinch","rotate","rotation","_handleTouchMove","updateGestureStatus","checkIfSingleTouchMove","checkIfMultiTouchMove","_this$gesture","z","allowGesture","direction","directionSetting","_this$gesture2","pan","moveStatus","_this$gesture2$availa","availablePan","eventName","checkIfMultiTouchEnd","_this$gesture3","_this$gesture4","_handleTouchEnd","doSingleTouchEnd","_handleTouchCancel","triggerAllowEvent","type","_this$gesture5","velocity","swipe","directionEvName","getTouchAction","_this$props2","key","value","componentWillUnmount","render","children","child","Children","only","touchAction","events","onTouchStart","onTouchMove","onTouchCancel","onTouchEnd","cloneElement","style","defaultProps"],"mappings":"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","sourcesContent":["import _extends from 'babel-runtime/helpers/extends';\r\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\r\nimport _createClass from 'babel-runtime/helpers/createClass';\r\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\r\nimport _inherits from 'babel-runtime/helpers/inherits';\r\n/* tslint:disable:no-console */\r\nimport React, { Component } from 'react';\r\nimport { calcRotation, getEventName, now, calcMutliFingerStatus, calcMoveStatus, shouldTriggerSwipe, shouldTriggerDirection, getMovingDirection, getDirectionEventName } from './util';\r\nimport { PRESS, DIRECTION_ALL, DIRECTION_VERTICAL, DIRECTION_HORIZONTAL } from './config';\r\n;\r\n;\r\nvar directionMap = {\r\n    all: DIRECTION_ALL,\r\n    vertical: DIRECTION_VERTICAL,\r\n    horizontal: DIRECTION_HORIZONTAL\r\n};\r\n\r\nvar Gesture = function (_Component) {\r\n    _inherits(Gesture, _Component);\r\n\r\n    function Gesture(props) {\r\n        _classCallCheck(this, Gesture);\r\n\r\n        var _this = _possibleConstructorReturn(this, (Gesture.__proto__ || Object.getPrototypeOf(Gesture)).call(this, props));\r\n\r\n        _this.state = {};\r\n        _this.triggerEvent = function (name) {\r\n            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\r\n                args[_key - 1] = arguments[_key];\r\n            }\r\n\r\n            var cb = _this.props[name];\r\n            if (typeof cb === 'function') {\r\n                // always give user gesture object as first params first\r\n                cb.apply(undefined, [_this.getGestureState()].concat(args));\r\n            }\r\n        };\r\n        _this.triggerCombineEvent = function (mainEventName, eventStatus) {\r\n            for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\r\n                args[_key2 - 2] = arguments[_key2];\r\n            }\r\n\r\n            _this.triggerEvent.apply(_this, [mainEventName].concat(args));\r\n            _this.triggerSubEvent.apply(_this, [mainEventName, eventStatus].concat(args));\r\n        };\r\n        _this.triggerSubEvent = function (mainEventName, eventStatus) {\r\n            for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\r\n                args[_key3 - 2] = arguments[_key3];\r\n            }\r\n\r\n            if (eventStatus) {\r\n                var subEventName = getEventName(mainEventName, eventStatus);\r\n                _this.triggerEvent.apply(_this, [subEventName].concat(args));\r\n            }\r\n        };\r\n        _this.triggerPinchEvent = function (mainEventName, eventStatus) {\r\n            for (var _len4 = arguments.length, args = Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\r\n                args[_key4 - 2] = arguments[_key4];\r\n            }\r\n\r\n            var scale = _this.gesture.scale;\r\n\r\n            if (eventStatus === 'move' && typeof scale === 'number') {\r\n                if (scale > 1) {\r\n                    _this.triggerEvent('onPinchOut');\r\n                }\r\n                if (scale < 1) {\r\n                    _this.triggerEvent('onPinchIn');\r\n                }\r\n            }\r\n            _this.triggerCombineEvent.apply(_this, [mainEventName, eventStatus].concat(args));\r\n        };\r\n        _this.initPressTimer = function () {\r\n            _this.cleanPressTimer();\r\n            _this.pressTimer = setTimeout(function () {\r\n                _this.setGestureState({\r\n                    press: true\r\n                });\r\n                _this.triggerEvent('onPress');\r\n            }, PRESS.time);\r\n        };\r\n        _this.cleanPressTimer = function () {\r\n            /* tslint:disable:no-unused-expression */\r\n            _this.pressTimer && clearTimeout(_this.pressTimer);\r\n        };\r\n        _this.setGestureState = function (params) {\r\n            if (!_this.gesture) {\r\n                _this.gesture = {};\r\n            }\r\n            // cache the previous touches\r\n            if (_this.gesture.touches) {\r\n                _this.gesture.preTouches = _this.gesture.touches;\r\n            }\r\n            _this.gesture = _extends({}, _this.gesture, params);\r\n        };\r\n        _this.getGestureState = function () {\r\n            if (!_this.gesture) {\r\n                return _this.gesture;\r\n            } else {\r\n                // shallow copy\r\n                return _extends({}, _this.gesture);\r\n            }\r\n        };\r\n        _this.cleanGestureState = function () {\r\n            delete _this.gesture;\r\n        };\r\n        _this.getTouches = function (e) {\r\n            return Array.prototype.slice.call(e.touches).map(function (item) {\r\n                return {\r\n                    x: item.screenX,\r\n                    y: item.screenY\r\n                };\r\n            });\r\n        };\r\n        _this.triggerUserCb = function (status, e) {\r\n            var cbName = getEventName('onTouch', status);\r\n            if (cbName in _this.props) {\r\n                _this.props[cbName](e);\r\n            }\r\n        };\r\n        _this._handleTouchStart = function (e) {\r\n            _this.triggerUserCb('start', e);\r\n            _this.event = e;\r\n            if (e.touches.length > 1) {\r\n                e.preventDefault();\r\n            }\r\n            _this.initGestureStatus(e);\r\n            _this.initPressTimer();\r\n            _this.checkIfMultiTouchStart();\r\n        };\r\n        _this.initGestureStatus = function (e) {\r\n            _this.cleanGestureState();\r\n            // store the gesture start state\r\n            var startTouches = _this.getTouches(e);\r\n            var startTime = now();\r\n            var startMutliFingerStatus = calcMutliFingerStatus(startTouches);\r\n            _this.setGestureState({\r\n                startTime: startTime,\r\n                startTouches: startTouches,\r\n                startMutliFingerStatus: startMutliFingerStatus,\r\n                /* copy for next time touch move cala convenient*/\r\n                time: startTime,\r\n                touches: startTouches,\r\n                mutliFingerStatus: startMutliFingerStatus,\r\n                srcEvent: _this.event\r\n            });\r\n        };\r\n        _this.checkIfMultiTouchStart = function () {\r\n            var _this$props = _this.props,\r\n                enablePinch = _this$props.enablePinch,\r\n                enableRotate = _this$props.enableRotate;\r\n            var touches = _this.gesture.touches;\r\n\r\n            if (touches.length > 1 && (enablePinch || enableRotate)) {\r\n                if (enablePinch) {\r\n                    var startMutliFingerStatus = calcMutliFingerStatus(touches);\r\n                    _this.setGestureState({\r\n                        startMutliFingerStatus: startMutliFingerStatus,\r\n                        /* init pinch status */\r\n                        pinch: true,\r\n                        scale: 1\r\n                    });\r\n                    _this.triggerCombineEvent('onPinch', 'start');\r\n                }\r\n                if (enableRotate) {\r\n                    _this.setGestureState({\r\n                        /* init rotate status */\r\n                        rotate: true,\r\n                        rotation: 0\r\n                    });\r\n                    _this.triggerCombineEvent('onRotate', 'start');\r\n                }\r\n            }\r\n        };\r\n        _this._handleTouchMove = function (e) {\r\n            _this.triggerUserCb('move', e);\r\n            _this.event = e;\r\n            if (!_this.gesture) {\r\n                // sometimes weird happen: touchstart -> touchmove..touchmove.. --> touchend --> touchmove --> touchend\r\n                // so we need to skip the unnormal event cycle after touchend\r\n                return;\r\n            }\r\n            // not a long press\r\n            _this.cleanPressTimer();\r\n            _this.updateGestureStatus(e);\r\n            _this.checkIfSingleTouchMove();\r\n            _this.checkIfMultiTouchMove();\r\n        };\r\n        _this.checkIfMultiTouchMove = function () {\r\n            var _this$gesture = _this.gesture,\r\n                pinch = _this$gesture.pinch,\r\n                rotate = _this$gesture.rotate,\r\n                touches = _this$gesture.touches,\r\n                startMutliFingerStatus = _this$gesture.startMutliFingerStatus,\r\n                mutliFingerStatus = _this$gesture.mutliFingerStatus;\r\n\r\n            if (!pinch && !rotate) {\r\n                return;\r\n            }\r\n            if (touches.length < 2) {\r\n                _this.setGestureState({\r\n                    pinch: false,\r\n                    rotate: false\r\n                });\r\n                // Todo: 2 finger -> 1 finger, wait to test this situation\r\n                pinch && _this.triggerCombineEvent('onPinch', 'cancel');\r\n                rotate && _this.triggerCombineEvent('onRotate', 'cancel');\r\n                return;\r\n            }\r\n            if (pinch) {\r\n                var scale = mutliFingerStatus.z / startMutliFingerStatus.z;\r\n                _this.setGestureState({\r\n                    scale: scale\r\n                });\r\n                _this.triggerPinchEvent('onPinch', 'move');\r\n            }\r\n            if (rotate) {\r\n                var rotation = calcRotation(startMutliFingerStatus, mutliFingerStatus);\r\n                _this.setGestureState({\r\n                    rotation: rotation\r\n                });\r\n                _this.triggerCombineEvent('onRotate', 'move');\r\n            }\r\n        };\r\n        _this.allowGesture = function () {\r\n            return shouldTriggerDirection(_this.gesture.direction, _this.directionSetting);\r\n        };\r\n        _this.checkIfSingleTouchMove = function () {\r\n            var _this$gesture2 = _this.gesture,\r\n                pan = _this$gesture2.pan,\r\n                touches = _this$gesture2.touches,\r\n                moveStatus = _this$gesture2.moveStatus,\r\n                preTouches = _this$gesture2.preTouches,\r\n                _this$gesture2$availa = _this$gesture2.availablePan,\r\n                availablePan = _this$gesture2$availa === undefined ? true : _this$gesture2$availa;\r\n\r\n            if (touches.length > 1) {\r\n                _this.setGestureState({\r\n                    pan: false\r\n                });\r\n                // Todo: 1 finger -> 2 finger, wait to test this situation\r\n                pan && _this.triggerCombineEvent('onPan', 'cancel');\r\n                return;\r\n            }\r\n            // add avilablePan condition to fix the case in scrolling, which will cause unavailable pan move.\r\n            if (moveStatus && availablePan) {\r\n                var direction = getMovingDirection(preTouches[0], touches[0]);\r\n                _this.setGestureState({ direction: direction });\r\n                var eventName = getDirectionEventName(direction);\r\n                if (!_this.allowGesture()) {\r\n                    // if the first move is unavailable, then judge all of remaining touch movings are also invalid.\r\n                    if (!pan) {\r\n                        _this.setGestureState({ availablePan: false });\r\n                    }\r\n                    return;\r\n                }\r\n                if (!pan) {\r\n                    _this.triggerCombineEvent('onPan', 'start');\r\n                    _this.setGestureState({\r\n                        pan: true,\r\n                        availablePan: true\r\n                    });\r\n                } else {\r\n                    _this.triggerCombineEvent('onPan', eventName);\r\n                    _this.triggerSubEvent('onPan', 'move');\r\n                }\r\n            }\r\n        };\r\n        _this.checkIfMultiTouchEnd = function (status) {\r\n            var _this$gesture3 = _this.gesture,\r\n                pinch = _this$gesture3.pinch,\r\n                rotate = _this$gesture3.rotate;\r\n\r\n            if (pinch) {\r\n                _this.triggerCombineEvent('onPinch', status);\r\n            }\r\n            if (rotate) {\r\n                _this.triggerCombineEvent('onRotate', status);\r\n            }\r\n        };\r\n        _this.updateGestureStatus = function (e) {\r\n            var time = now();\r\n            _this.setGestureState({\r\n                time: time\r\n            });\r\n            if (!e.touches || !e.touches.length) {\r\n                return;\r\n            }\r\n            var _this$gesture4 = _this.gesture,\r\n                startTime = _this$gesture4.startTime,\r\n                startTouches = _this$gesture4.startTouches,\r\n                pinch = _this$gesture4.pinch,\r\n                rotate = _this$gesture4.rotate;\r\n\r\n            var touches = _this.getTouches(e);\r\n            var moveStatus = calcMoveStatus(startTouches, touches, time - startTime);\r\n            var mutliFingerStatus = void 0;\r\n            if (pinch || rotate) {\r\n                mutliFingerStatus = calcMutliFingerStatus(touches);\r\n            }\r\n            _this.setGestureState({\r\n                /* update status snapshot */\r\n                touches: touches,\r\n                mutliFingerStatus: mutliFingerStatus,\r\n                /* update duration status */\r\n                moveStatus: moveStatus\r\n            });\r\n        };\r\n        _this._handleTouchEnd = function (e) {\r\n            _this.triggerUserCb('end', e);\r\n            _this.event = e;\r\n            if (!_this.gesture) {\r\n                return;\r\n            }\r\n            _this.cleanPressTimer();\r\n            _this.updateGestureStatus(e);\r\n            _this.doSingleTouchEnd('end');\r\n            _this.checkIfMultiTouchEnd('end');\r\n        };\r\n        _this._handleTouchCancel = function (e) {\r\n            _this.triggerUserCb('cancel', e);\r\n            _this.event = e;\r\n            // Todo: wait to test cancel case\r\n            if (!_this.gesture) {\r\n                return;\r\n            }\r\n            _this.cleanPressTimer();\r\n            _this.updateGestureStatus(e);\r\n            _this.doSingleTouchEnd('cancel');\r\n            _this.checkIfMultiTouchEnd('cancel');\r\n        };\r\n        _this.triggerAllowEvent = function (type, status) {\r\n            if (_this.allowGesture()) {\r\n                _this.triggerCombineEvent(type, status);\r\n            } else {\r\n                _this.triggerSubEvent(type, status);\r\n            }\r\n        };\r\n        _this.doSingleTouchEnd = function (status) {\r\n            var _this$gesture5 = _this.gesture,\r\n                moveStatus = _this$gesture5.moveStatus,\r\n                pinch = _this$gesture5.pinch,\r\n                rotate = _this$gesture5.rotate,\r\n                press = _this$gesture5.press,\r\n                pan = _this$gesture5.pan,\r\n                direction = _this$gesture5.direction;\r\n\r\n            if (pinch || rotate) {\r\n                return;\r\n            }\r\n            if (moveStatus) {\r\n                var z = moveStatus.z,\r\n                    velocity = moveStatus.velocity;\r\n\r\n                var swipe = shouldTriggerSwipe(z, velocity);\r\n                _this.setGestureState({\r\n                    swipe: swipe\r\n                });\r\n                if (pan) {\r\n                    // pan need end, it's a process\r\n                    // sometimes, start with pan left, but end with pan right....\r\n                    _this.triggerAllowEvent('onPan', status);\r\n                }\r\n                if (swipe) {\r\n                    var directionEvName = getDirectionEventName(direction);\r\n                    // swipe just need a direction, it's a endpoint\r\n                    _this.triggerAllowEvent('onSwipe', directionEvName);\r\n                    return;\r\n                }\r\n            }\r\n            if (press) {\r\n                _this.triggerEvent('onPressUp');\r\n                return;\r\n            }\r\n            _this.triggerEvent('onTap');\r\n        };\r\n        _this.getTouchAction = function () {\r\n            var _this$props2 = _this.props,\r\n                enablePinch = _this$props2.enablePinch,\r\n                enableRotate = _this$props2.enableRotate;\r\n            var directionSetting = _this.directionSetting;\r\n\r\n            if (enablePinch || enableRotate || directionSetting === DIRECTION_ALL) {\r\n                return 'pan-x pan-y';\r\n            }\r\n            if (directionSetting === DIRECTION_VERTICAL) {\r\n                return 'pan-x';\r\n            }\r\n            if (directionSetting === DIRECTION_HORIZONTAL) {\r\n                return 'pan-y';\r\n            }\r\n            return 'auto';\r\n        };\r\n        _this.directionSetting = directionMap[props.direction];\r\n        return _this;\r\n    }\r\n\r\n    _createClass(Gesture, [{\r\n        key: 'componentWillUnmount',\r\n        value: function componentWillUnmount() {\r\n            this.cleanPressTimer();\r\n        }\r\n    }, {\r\n        key: 'render',\r\n        value: function render() {\r\n            var children = this.props.children;\r\n\r\n            var child = React.Children.only(children);\r\n            var touchAction = this.getTouchAction();\r\n            var events = {\r\n                onTouchStart: this._handleTouchStart,\r\n                onTouchMove: this._handleTouchMove,\r\n                onTouchCancel: this._handleTouchCancel,\r\n                onTouchEnd: this._handleTouchEnd\r\n            };\r\n            return React.cloneElement(child, _extends({}, events, { style: _extends({ touchAction: touchAction }, child.props.style || {}) }));\r\n        }\r\n    }]);\r\n\r\n    return Gesture;\r\n}(Component);\r\n\r\nexport default Gesture;\r\n\r\nGesture.defaultProps = {\r\n    enableRotate: false,\r\n    enablePinch: false,\r\n    direction: 'all'\r\n};"]},"metadata":{},"sourceType":"module"}